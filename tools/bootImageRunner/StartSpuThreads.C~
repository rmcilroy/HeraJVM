#include   <stdlib.h>
#include   <stdio.h>
#include   <malloc.h>
#include   <errno.h>
#include   <libspe2.h>
#include   <pthread.h>


extern spe_program_handle_t cellspu_bootloader;

#define MAX_SPU_THREADS 16
#define CTX_FLAGS SPE_MAP_PS | SPE_EVENTS_ENABLE

void * spu_bootstrap_thread(void *arg) {
	spe_context_ptr_t ctx;
	unsigned int entry = SPE_DEFAULT_ENTRY;
	ctx = *((spe_context_ptr_t *)arg);

	if (spe_context_run(ctx, &entry, 0, NULL, NULL, NULL) < 0) {
		perror ("Failed to start Cell SPU context");
		exit (1);
	}
	pthread_exit(NULL);
}

int main() {

	int i, spu_threads;
	spe_gang_context_ptr_t spe_gang;
	spe_context_ptr_t ctxs [MAX_SPU_THREADS];
	pthread_t threads[MAX_SPU_THREADS];


	/* Determine the number of SPE threads to create */
	spu_threads = spe_cpu_info_get(SPE_COUNT_USABLE_SPES, -1);
	if (spu_threads > MAX_SPU_THREADS) spu_threads = MAX_SPU_THREADS;

	printf("Bringing up %i spu threads\n");

	/* create the context gang */
	if ((spe_gang = spe_gang_context_create(0)) == NULL) {
		perror("Failed creating Cell SPU gang context");
		exit(1);
	}

	for(i=0; i<spu_threads; i++) {
		/* Create context */
		if ((ctxs[i] = spe_context_create (CTX_FLAGS, spe_gang)) == NULL) {
			perror ("Failed creating Cell SPU context %i", i);
			exit (1);
		}

		/* load bootloader into spu's */
		if (spe_program_load (ctxs[i],&cellspu_bootloader)) {
			perror ("Failed loading Cell SPU bootloader");
			exit (1);
		}

		/* create a thread for each SPU */
		if (pthread_create (&threads[i], NULL,&ppu_pthread_function,&ctxs[i])) {
			perror ("Failed creating Cell SPU thread");
			exit (1);
		}

		

	}
}
